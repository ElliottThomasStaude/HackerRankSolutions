/*
Transcript of problem:

Given an array A[] of N distinct elements. Let M_1 and M_2 be the smallest and the next smallest element in the interval [L, R] where 1 <= L < R <= N.

S_i = (((M_1 ^ M_2) (+) (M_1 v M_2)) ^ (M_1 (+) M2)).

where ^, v, (+) are the bitwise operators AND, OR, and XOR respectively.
Your task is to find the maximum possible value of S_i.

-- Input Format

First line contains integer N.
Second line contains N integers, representing elements of the array A[].

-- Constraints 

1 < N <= 10^6
1 <= A_i <= 10^9

-- Output Format

Print the value of maximum possible value of S_i.

*/

import java.io.*;
import java.util.*;

public class Solution {
	
	/*
		The operation sequence (((a AND b) XOR (a OR b)) AND (a XOR b)) is actually equal to (a XOR b). This means that the
		final goal is to ascertain which pair of members has the highest XOR value. This pair of members will, if it is
		possible, contain exactly one number larger than or equal to the largest power-of-two bit value in the array of
		inputs. For example, in the array [1, 5, 5, 17, 16, 4], the highest XOR value will include either 17 or 16, because
		the 2^4 = 16 bit will only be in a XOR result if it is in one or the other of its inputs, and this is the highest
		bit available in the input array.
	*/
	
    public static ArrayDeque<Integer> sequenceContent = new ArrayDeque<Integer>();
    public static TreeMap<Integer, Integer> countMap = new TreeMap<Integer, Integer>();
    public static int[] storageArray;
	public static boolean[] hasPowerOf2Value;
    public static int smallestValue = 1000000001;
    public static int secondSmallestValue = 1000000001;
    
	// If "forwardEnd" is true, the element is added at the back; otherwise it is added at the front
    public static int addToSequence(int inputIndex, boolean forwardEnd) {
    	int addedValue = storageArray[inputIndex];
    	if (forwardEnd) {
    		sequenceContent.push(addedValue);
    	} else {
    		sequenceContent.add(addedValue);
    	}
    	if (countMap.containsKey(addedValue)) {
    		countMap.put(addedValue, countMap.get(addedValue) + 1);
    	} else {
    		countMap.put(addedValue, 1);
    	}
//    	if (smallestValue > addedValue) {
//    		secondSmallestValue = smallestValue;
//    		smallestValue = addedValue;
//    	} else if (secondSmallestValue > addedValue) {
//    		secondSmallestValue = addedValue;
//    	}
    	return addedValue;
    }
    
    // If "forwardEnd" is true, the last element is the removed element; otherwise it is the first element
    public static int removeFromSequence(boolean forwardEnd) {
    	int removedValue;
    	if (forwardEnd) {
    		removedValue = sequenceContent.pop();
    	} else {
    		removedValue = sequenceContent.removeLast();
    	}
    	int tally = countMap.get(removedValue);
    	if (tally > 1) {
    		countMap.put(removedValue, tally - 1);
    	} else {
    		countMap.remove(removedValue);
//    		if (removedValue <= secondSmallestValue) {
//    			if (smallestValue == removedValue) {
//	    			smallestValue = secondSmallestValue;
//	    		}
//	    		if (countMap.get(countMap.firstKey()) == 1) {
//	    			secondSmallestValue = countMap.higherKey(countMap.firstKey());
//	    		}
//    		}
    	}
    	return removedValue;
    }
    
    public static void main(String[] args) {
    	Scanner inputScanner = new Scanner(System.in);
    	
    	int numberCount = inputScanner.nextInt();
    	
    	storageArray = new int[numberCount];
    	hasPowerOf2Value = new boolean[numberCount];
    	int highestPowerOf2 = 1;
    	int lowest2PowerCeiling = 2;
    	int logHighest2Power = 0;
    	
    	int xorValue = 0;
    	
    	int inequalityValue = -1;
    	boolean homogeneousInputs = true;
    	
        for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
        	int inputValue = inputScanner.nextInt();
        	if (homogeneousInputs && inequalityValue != inputValue) {
        		if (inequalityValue == -1) {
        			inequalityValue = inputValue;
        		} else {
        			homogeneousInputs = false;
        		}
        	}
        	if (inputValue >= lowest2PowerCeiling) {
        		while (highestPowerOf2 <= inputValue) {
        			highestPowerOf2 *= 2;
        		}
        		lowest2PowerCeiling = highestPowerOf2;
        		highestPowerOf2 /= 2;
        		logHighest2Power = (int) (Math.log10(highestPowerOf2) / Math.log10(2));
        	}
        	storageArray[inputIndex] = inputValue;
	    }
        
        // Determine which numbers have the largest bit set, and record that in an array
        // If all numbers have the single largest bit set, then reduce them by that power of 2 and repeat the process until some numbers have their largest bit set and some do not
    	boolean powersOf2Unstable = true;
        while (powersOf2Unstable) {
    		for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
            	if (storageArray[inputIndex] >= highestPowerOf2) {
            		hasPowerOf2Value[inputIndex] = true;
            	} else {
            		hasPowerOf2Value[inputIndex] = false;
            		if (powersOf2Unstable) {
            			powersOf2Unstable = false;
            		}
            	}
    	    }
    		if (powersOf2Unstable) {
    			if (homogeneousInputs) {
    				xorValue = 0;
    				powersOf2Unstable = false;
    			} else {
    				int oldHighestPowerOf2 = highestPowerOf2;
    				highestPowerOf2 = 1;
    		    	lowest2PowerCeiling = 2;
    		    	logHighest2Power = 0;
    				for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
    					storageArray[inputIndex] -= oldHighestPowerOf2;
    		        	int inputValue = storageArray[inputIndex];
    		        	if (inputValue >= lowest2PowerCeiling) {
    		        		while (highestPowerOf2 <= inputValue) {
    		        			highestPowerOf2 *= 2;
    		        		}
    		        		lowest2PowerCeiling = highestPowerOf2;
    		        		highestPowerOf2 /= 2;
    		        		logHighest2Power = (int) (Math.log10(highestPowerOf2) / Math.log10(2));
    		        	}
    			    }
    			}
    		}
    	}
        
        // Processing: each sequence has two terminations; the starting termination moves down the array of inputs in an almost normal for-loop
        // The ending termination alternates in moving up the array in the same direction as the starting termination and moving down in the opposite direction

        int numberCountDecrement = numberCount - 1;
        int currentStartPosition = 0;
        int currentEndPosition = 1;
        
        addToSequence(0, true);
        
        while (currentStartPosition < numberCountDecrement) {	
        	while (currentEndPosition < numberCount) {
        		addToSequence(currentEndPosition, true);
        		currentEndPosition++;
        	}
        	
        	System.out.println(currentStartPosition);
        	System.out.println(currentEndPosition);
        	System.out.println(Arrays.toString(sequenceContent.toArray()));
        	
        	currentStartPosition++;
        	removeFromSequence(false);
        	
        	while (currentEndPosition > currentStartPosition + 2) {
        		currentEndPosition--;
        		removeFromSequence(true);
        	}
        	
        	System.out.println(currentStartPosition);
        	System.out.println(currentEndPosition);
        	System.out.println(Arrays.toString(sequenceContent.toArray()));
        	
        	removeFromSequence(false);
        	currentStartPosition++;
        	addToSequence(currentStartPosition, true);
        }
        System.out.println(Arrays.toString(sequenceContent.toArray()));
        
        System.out.println(xorValue);
        
        inputScanner.close();
    }
}
