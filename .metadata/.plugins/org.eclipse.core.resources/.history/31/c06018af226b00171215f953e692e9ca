/*
Transcript of problem:

Given an array A[] of N distinct elements. Let M_1 and M_2 be the smallest and the next smallest element in the interval [L, R] where 1 <= L < R <= N.

S_i = (((M_1 ^ M_2) (+) (M_1 v M_2)) ^ (M_1 (+) M2)).

where ^, v, (+) are the bitwise operators AND, OR, and XOR respectively.
Your task is to find the maximum possible value of S_i.

-- Input Format

First line contains integer N.
Second line contains N integers, representing elements of the array A[].

-- Constraints 

1 < N <= 10^6
1 <= A_i <= 10^9

-- Output Format

Print the value of maximum possible value of S_i.

*/

import java.io.*;
import java.util.*;

public class Solution {
	
	/*
		The operation sequence (((a AND b) XOR (a OR b)) AND (a XOR b)) is actually equal to (a XOR b). This means that the
		final goal is to ascertain which pair of members has the highest XOR value. This pair of members will, if it is
		possible, contain exactly one number larger than or equal to the largest power-of-two bit value in the array of
		inputs. For example, in the array [1, 5, 5, 17, 16, 4], the highest XOR value will include either 17 or 16, because
		the 2^4 = 16 bit will only be in a XOR result if it is in one or the other of its inputs, and this is the highest
		bit available in the input array.
	*/
	
	
    public static void main(String[] args) {
    	Scanner inputScanner = new Scanner(System.in);
    	
    	int numberCount = inputScanner.nextInt();
    	
    	int[] storageArray = new int[numberCount];
    	boolean[] hasPowerOf2Value = new boolean[numberCount];
    	int highestPowerOf2 = 1;
    	int lowest2PowerCeiling = 2;
    	int logHighest2Power = 0;
    	
    	int xorValue = 1;
    	
    	int inequalityValue = -1;
    	boolean notHomogeneousInputs = false;
    	
        for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
        	int inputValue = inputScanner.nextInt();
        	if (!notHomogeneousInputs && inequalityValue != inputValue) {
        		if (inequalityValue == -1) {
        			inequalityValue = inputValue;
        		} else {
        			notHomogeneousInputs = true;
        		}
        	}
        	if (inputValue >= lowest2PowerCeiling) {
        		while (highestPowerOf2 <= inputValue) {
        			highestPowerOf2 *= 2;
        		}
        		lowest2PowerCeiling = highestPowerOf2;
        		highestPowerOf2 /= 2;
        		logHighest2Power = (int) (Math.log10(highestPowerOf2) / Math.log10(2));
        	}
        	storageArray[inputIndex] = inputValue;
	    }
        
        // Determine which numbers have the largest bit set, and record that in an array
        // If all numbers have the single largest bit set, then reduce them by that power of 2 and repeat the process until some numbers have their largest bit set and some do not
    	boolean powersOf2Unstable = true;
        while (powersOf2Unstable) {
    		for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
            	if (storageArray[inputIndex] >= highestPowerOf2) {
            		hasPowerOf2Value[inputIndex] = true;
            	} else {
            		hasPowerOf2Value[inputIndex] = false;
            		if (powersOf2Unstable) {
            			powersOf2Unstable = false;
            		}
            	}
    	    }
    		if (powersOf2Unstable) {
    			if (!notHomogeneousInputs) {
    				xorValue = 0;
    				powersOf2Unstable = false;
    			} else {
    				oldHighestPowerOf2 = highestPowerOf2;
    				highestPowerOf2 = 1;
    		    	lowest2PowerCeiling = 2;
    		    	logHighest2Power = 0;
    				for (int inputIndex = 0; inputIndex < numberCount; inputIndex++) {
    		        	int inputValue = storageArray[inputIndex];
    		        	if (inputValue >= lowest2PowerCeiling) {
    		        		while (highestPowerOf2 <= inputValue) {
    		        			highestPowerOf2 *= 2;
    		        		}
    		        		lowest2PowerCeiling = highestPowerOf2;
    		        		highestPowerOf2 /= 2;
    		        		logHighest2Power = (int) (Math.log10(highestPowerOf2) / Math.log10(2));
    		        	}
    			    }
    			}
    		}
    	}
        System.out.println(xorValue);
        
        numberCount = inputScanner.nextInt();
        
        inputScanner.close();
    }
}
