/*
Transcript of problem:

Alexa has two stacks of non-negative integers, stack A = [a_0, a_1, ..., a_n-1] and stack B = [b_0, b_1, ..., b_m-1] where index 0 denotes the top of the stack. Alexa challenges Nick to play the following game:

In each move, Nick can remove one integer from the top of either stack A or stack B.
Nick keeps a running sum of the integers he removes from the two stacks.
Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer x given at the beginning of the game.
Nick's final score is the total number of integers he has removed from the two stacks.

Given A, B, and x for g games, find the maximum possible score Nick can achieve (i.e., the maximum number of integers he can remove without being disqualified during each game and print it on a new line.

-- Input Format

The first line contains an integer, g (the number of games). The 3g subsequent lines describe each game in the following format:
1. The first line contains three space separated integers describing the respective values of n (the number of integers in stack A), m (the number of integers in stack B), and x (the number that the sum of the integers removed from the two stacks cannot exceed).
2. The second line contains n space-separated integers describing the respective values of a_0, a_1, ..., a_n-1.
3. The third line contains m space-separated integers describing the respective values of b_0, b_1, ..., b_m-1.

-- Constraints

1 <= g <= 50
1 <= n, m <= 10^5
0 <= a_i, b_j <= 10^6
1 <= x <= 10^9

-- Subtasks

1 <= n, m, <= 100 for 50% of the maximum score.

-- Output Format

For each of the g games, print an integer on a new line denoting the maximum possible score Nick can achieve without being disqualified.
*/

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

	/*
	The starting point is to remove as many elements from stack A as possible, so that the removed elements have a sum less than 
	or equal to x. After removing these elements, they should be placed on a holder stack; one at a time, the holder stack's
	contents should be popped off (having fewer elements on the holder stack represents "taking" fewer elements from stack A), 
	and as many elements from stack B should be removed as will keep the sum of the removed elements from stack A and stack B 
	equal to or lower than x. After all the elements have been removed from the holder stack, the maximum count of elements 
	whose sum is less than or equal to x is the best score possible.
	*/
	
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int g = in.nextInt();
        for (int a0 = 0; a0 < g; a0++) {
            int n = in.nextInt();
            int m = in.nextInt();
            int x = in.nextInt();
            ArrayDeque<Integer> stackA = new ArrayDeque<Integer>();
            for (int a_i=0; a_i < n; a_i++) {
            	stackA.add(in.nextInt());
            }
            ArrayDeque<Integer> stackB = new ArrayDeque<Integer>();
            for (int b_i=0; b_i < m; b_i++) {
            	stackB.add(in.nextInt());
            }
            Stack<Integer> stackAHolder = new Stack<Integer>();
            int aCount = 0;
            int bCount = 0;
            int stackASum = 0;
            while (stackASum < x) {
            	int topValue = stackA.pop();
            	stackASum += topValue;
            	stackAHolder.push(topValue);
            	aCount++;
            }
        	int bestMaxValue = aCount;
        	int stackBSum = 0;
        	int lastBValue = 0;
            while (!stackAHolder.empty()) {
            	int removedValue = stackAHolder.pop();
            	stackASum -= removedValue;
            	aCount--;
            	while (stackASum + stackBSum < x) {
                	lastBValue = stackB.pop();
                	stackBSum += lastBValue;
                	bCount++;
                }
            	if (stackASum + stackBSum > x) {
            		stackBSum -= lastBValue;
            		stackB.push(lastBValue);
            		bCount--;
            	}
            	if (bestMaxValue < aCount + bCount) {
	            	bestMaxValue = aCount + bCount;
	            }
            }
            System.out.println(bestMaxValue);
        }
    }
}