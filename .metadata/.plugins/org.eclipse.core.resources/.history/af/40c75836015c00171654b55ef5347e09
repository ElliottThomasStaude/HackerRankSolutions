/*
Transcript of problem:

You are given Q queries. Each query consists of a single number N. You can perform any of the 2 operations on N in each move:

1: If we take 2 integers a and b where N = a x b (a != 1, b != 1) then we can change N = max(a, b)

2: Decrease the value of N by 1.

Determine the minimum number of moves required to reduce the value of N to 0.

--Input Format

The first line contains the integer Q.
The next Q lines each contain an integer, N.

--Constraints

1 <= Q <= 10^3
0 <= N <= 10^6

--Output Format

Output Q lines. Each line containing the minimum number of moves required to reduce the value of N to 0.
*/


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner inputScanner = new Scanner(System.in);
        int maximumNumber = 1000000;
        ArrayList<Integer> sizeOfSteps = new ArrayList<Integer>(maximumNumber);
        sizeOfSteps.add(1);
        sizeOfSteps.add(2);
        sizeOfSteps.add(3);
        sizeOfSteps.add(3);
        
        for (int positionIndex = 4; positionIndex < maximumNumber; positionIndex++) {
        	sizeOfSteps.add(positionIndex);
        }
        
        int lastStepCount = 3;
        
        for (int positionIndex = 3; positionIndex < maximumNumber; positionIndex++) {
        	if (sizeOfSteps.get(positionIndex) > lastStepCount + 1) {
        		sizeOfSteps.set(positionIndex, lastStepCount + 1);
        	}
        	int currentCount = sizeOfSteps.get(positionIndex);
        	int actualValue = positionIndex + 1;
        	
        	int maximumProductInt = Math.floorDiv(maximumNumber, actualValue);
        	int limitCeiling = Math.min(maximumProductInt, actualValue);
        	for (int innerPositionIndex = 2; innerPositionIndex <= limitCeiling; innerPositionIndex++) {
        		int product = innerPositionIndex * actualValue;
        		if (sizeOfSteps.get(product - 1) > currentCount + 1) {
        			sizeOfSteps.set(product - 1, currentCount + 1);
        		}
        	}
        	
        	lastStepCount = currentCount;
        }
        
        // System.out.println(Arrays.toString(sizeOfSteps.toArray()));
        for (int queryIndex = 0; queryIndex < 100; queryIndex++) {
        	System.out.println(sizeOfSteps.get(queryIndex));
        }
        // END
        int queryCount = inputScanner.nextInt();
        
        for (int queryIndex = 0; queryIndex < queryCount; queryIndex++) {
            int parentNumber = inputScanner.nextInt();
            int moveCount = sizeOfSteps.get(parentNumber - 1);
            System.out.println(moveCount);
        }
    }
}